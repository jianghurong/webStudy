## React diffing算法  

原因: 在某一时间节点调用React的render()方法，会创建一棵由React元素组成的树。在下一次state和props更新时，相同的render()方法会返回不同的树。所以需要一种算法来高效的更新UI来保证当前UI与最新的树同步。

作用: 保证组件更新具有**可预测性**，以及在繁杂业务下依然保持应用的**高性能性**

通用解决方案: 生成一棵树转换成另一棵树的最小操作数，算法复杂度为O(n3)，其中n是树中元素的数量。

通用解决方案优化: React在以下两个假设的基础上提出了一套算法复杂度为O(n)的启发式算法。  
1.两个不同类型的元素会产生不同的树  
2.可以通过**key**、**props**来暗示哪些子元素在不同的渲染下能保持稳定

---
## Diffing 算法
当对比两棵树时，React首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。  
### 比较不同类型的元素
当根节点为不同元素的类型时，React会拆卸原有的树并且建立起新的树。举个例子，当元素从```<div>变成<span>```，会触发一个完整的重建流程。  
当拆卸一棵树时，对应的DOM节点也会被销毁。组件实例将执行componentWillUnmount()方法。当建立一颗新的树时，对应的DOM节点会被创建及插入到DOM中。组件实例将执行componetWillmount()方法。所以跟之前项链的state将会被销毁。如下:  
```html
<div>
  <counter />
</div>

<span>
  <counter />
</span>
<!-- React会销毁counter组件 -->
```

### 比较同一类型的元素
当对比两个相同类型的元素，React会保留其DOM节点，仅对比及更新有改变的属性。
如下:  

```html
<div className="before" />
<div className="after" />
```

### 比较同一类型的组件元素
当一个组件更新时，组件实例保持不变，这样state在跨越不同的渲染时保持一致。React将更新该组件实例的props以跟更新的元素保持一致，并且调用该实例的```componentWillReceiveProps()```和```componentWillUpdate()```方法。下一步，调用render()方法。diff算法将在之前的结果以及新的结果中执行递归。